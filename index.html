<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku Mini App</title>
  <style>
    :root {
      --bg: #0b0c10;
      --panel: #121319;
      --grid: #1a1c24;
      --accent: #4cc9f0;
      --danger: #ff5c7a;
      --muted: #8a8fa3;
      --text: #e9ecf1;
      --given: #a0c4ff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji';
      background: radial-gradient(1200px 600px at 10% 0%, #12131a, #0b0c10 60%);
      color: var(--text);
    }
    .app { max-width: 980px; margin: 0 auto; display: grid; grid-template-columns: 1fr 340px; gap: 20px; align-items: start; }
    header { grid-column: 1/-1; display:flex; align-items:center; justify-content: space-between; margin-bottom: 6px; }
    h1 { font-size: 20px; letter-spacing: .3px; margin: 0; font-weight: 700; }
    .grid {
      width: 100%; aspect-ratio: 1 / 1; background: var(--panel); padding: 10px; border-radius: 18px; box-shadow: var(--shadow);
      display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); gap: 2px;
    }
    .cell {
      position: relative; background: var(--grid); border-radius: 8px; overflow: hidden; cursor: pointer; outline: none; border: 1px solid transparent; transition: transform .02s ease;
    }
    .cell:active { transform: scale(.998); }
    .cell[aria-selected="true"] { border-color: var(--accent); box-shadow: 0 0 0 1.5px var(--accent) inset; }
    .value { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight: 700; font-size: clamp(16px, 3.2vmin, 28px); }
    .value.given { color: var(--given); }
    .value.user { color: var(--text); }
    .value.conflict { color: var(--danger); }
    .pencils { position:absolute; inset:0; display:none; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 1px; padding: 4px; }
    .pencil { display:flex; align-items:center; justify-content:center; font-size: clamp(8px, 1.5vmin, 13px); color: var(--muted); opacity:.7; }
    .pencil.on { display:flex; align-items:center; justify-content:center; font-size: clamp(8px, 1.5vmin, 13px); color: #c6d0ff; font-weight: 600; opacity: 1; }
    .grid.show-pencils .pencils { display: grid; }
    /* thick box borders */
    .cell[data-r="2"], .cell[data-r="5"] { border-bottom: 2px solid #2a2f3d; }
    .cell[data-c="2"], .cell[data-c="5"] { border-right: 2px solid #2a2f3d; }

    .side { background: var(--panel); padding: 14px; border-radius: 18px; box-shadow: var(--shadow); }
    .toolbar { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .toolbar + .toolbar { margin-top: 10px; }
    .btn { padding: 10px 12px; border-radius: 12px; background: #171923; border: 1px solid #262b39; color: var(--text); cursor: pointer; font-weight: 600; letter-spacing:.2px; }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: #17202a; border-color: #2d3a4f; }
    .btn.accent { background: #0e2230; border-color: #234a67; color: #bce7ff; }
    .btn.danger { background: #2b0f14; border-color: #4a1b24; color: #ffc2ce; }
    .mode { margin: 10px 0 14px; display:flex; gap:8px; align-items:center; }
    .switch { position: relative; width: 54px; height: 30px; background: #171923; border: 1px solid #2b3040; border-radius: 999px; cursor:pointer; }
    .knob { position:absolute; top:3px; left:3px; width:24px; height:24px; background: #2e3448; border-radius:50%; transition: left .2s; }
    .switch.on .knob { left:27px; background: #2b7ab3; }
    .muted { color: var(--muted); font-size: 12px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#161821; padding:2px 6px; border-radius:6px; border:1px solid #2b3040; }
    textarea { width: 100%; min-height: 82px; background:#0f1118; color: var(--text); border:1px solid #2b3040; border-radius: 10px; padding: 8px; resize: vertical; }
    .row { display:flex; gap:8px; align-items:center; justify-content: space-between; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.35; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#0f2230; border:1px solid #21445e; color:#bfe7ff; font-size:12px; font-weight:700; letter-spacing:.3px; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <h1>🧩 Sudoku Mini App <span class="badge">输入起局 → 锁定 → 解题</span></h1>
      <div class="hint">键盘：<span class="kbd">1-9</span> 填数，<span class="kbd">Backspace/0</span> 清空，<span class="kbd">←↑→↓</span> 移动，<span class="kbd">Shift</span> 临时铅笔</div>
    </header>

    <main>
      <div class="grid" id="grid" role="grid" aria-label="Sudoku grid"></div>
    </main>

    <aside class="side">
      <div class="row"><strong>模式</strong><span id="modeLabel" class="muted">数字</span></div>
      <div class="mode">
        <div id="modeSwitch" class="switch" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div>
        <div class="hint">切换“数字/铅笔”模式（按住 <span class="kbd">Shift</span> 也可临时切到铅笔）</div>
      </div>

      <div class="toolbar">
        <button class="btn primary" id="lockBtn" title="锁定当前非空格为起始题面">🔒 锁定起局</button>
        <button class="btn" id="unlockBtn" title="取消所有起局锁定">🔓 取消锁定</button>
        <button class="btn" id="clearBtn">🧹 清空</button>
      </div>
      <div class="toolbar">
        <button class="btn" id="undoBtn">↶ 撤销</button>
        <button class="btn" id="redoBtn">↷ 重做</button>
        <button class="btn danger" id="eraseBtn">⌫ 清除格</button>
      </div>

      <hr style="border-color:#1f2431; opacity:.6; margin:14px 0;">

      <div class="row"><strong>导入 / 导出</strong></div>
      <div class="toolbar">
        <button class="btn accent" id="exportBtn">⬇ 导出 JSON</button>
        <button class="btn" id="importBtn">⬆ 导入 JSON</button>
        <button class="btn" id="saveBtn" title="保存到本地浏览器">💾 保存</button>
      </div>
      <div class="toolbar">
        <button class="btn accent" id="candsBtn" title="根据当前盘面计算所有候选">✳ 计算候选</button>
        <button class="btn" id="stepBtn" title="按规则做一步逻辑（裸单/隐单/指向对）">🧠 逻辑一步</button>
        <button class="btn" id="autoBtn" title="反复执行直到无法推进或完成">⚡ 自动解</button>
      </div>
      <textarea id="ioArea" placeholder='可粘贴/查看 JSON；或用 81 字符串（0/点/空=空格）'></textarea>
      <div class="hint" style="margin-top:6px;">粘贴 81 字符串示例：<span class="kbd">530070000600195000098000060800060003400803001700020006060000280000419005000080079</span></div>

      <hr style="border-color:#1f2431; opacity:.6; margin:14px 0;">
      <div class="hint">提示：红色表示当前行/列/宫存在冲突；蓝色为起局锁定数字。后续可以把“求解器”接在导入的盘面上。</div>
    </aside>
  </div>

<script>
(function(){
  /*** Data Model ***/
  const N = 9;
  const size = N*N;
  /** @typedef {{value:number|null,given:boolean,pencil:Set<number>}} Cell */
  /** @type {Cell[]} */
  let board = Array.from({length:size},()=>({value:null,given:false,pencil:new Set()}));
  let selected = 0;
  let pencilMode = false;
  let shiftHeld = false;
  const history = []; const future = [];

  const gridEl = document.getElementById('grid');
  const ioArea = document.getElementById('ioArea');
  const modeSwitch = document.getElementById('modeSwitch');
  const modeLabel = document.getElementById('modeLabel');
  const DIGITS = [1,2,3,4,5,6,7,8,9];
  const ROWS = Array.from({length:9}, (_,r)=> Array.from({length:9},(_,c)=> r*9+c));
  const COLS = Array.from({length:9}, (_,c)=> Array.from({length:9},(_,r)=> r*9+c));
  const BOXES = Array.from({length:9}, (_,b)=>{ const br=Math.floor(b/3)*3, bc=(b%3)*3; return Array.from({length:9}, (_,k)=> (br+Math.floor(k/3))*9 + (bc+(k%3))); });

  function updatePencilVisibility(){
    gridEl.classList.toggle('show-pencils', realPencilMode());
  }

  /*** Helpers ***/
  const rc = idx => [Math.floor(idx/9), idx%9];
  const boxId = (r,c)=> Math.floor(r/3)*3 + Math.floor(c/3);
  function cloneBoard(b){
    return b.map(c=>({value:c.value,given:c.given,pencil:new Set(c.pencil)}));
  }
  function pushHistory(){ history.push(JSON.stringify(serialize())); future.length=0; }
  function undo(){ if(history.length){ future.push(JSON.stringify(serialize())); deserialize(JSON.parse(history.pop())); render(); select(selected); }}
  function redo(){ if(future.length){ history.push(JSON.stringify(serialize())); deserialize(JSON.parse(future.pop())); render(); select(selected); }}

  /*** Rendering ***/
  function makeCell(idx){
    const [r,c] = rc(idx);
    const cell = document.createElement('div');
    cell.className='cell';
    cell.tabIndex=0;
    cell.dataset.i = idx;
    cell.dataset.r = r; cell.dataset.c = c;

    const pencils = document.createElement('div');
    pencils.className='pencils';
    for(let d=1; d<=9; d++){
      const p = document.createElement('div');
      p.className='pencil'; p.textContent=String(d);
      p.dataset.d = d;
      p.addEventListener('click', (e)=>{
        e.stopPropagation();
        handleDigit(d, true);
      });
      pencils.appendChild(p);
    }

    const value = document.createElement('div'); value.className='value';
    cell.appendChild(pencils); cell.appendChild(value);

    cell.addEventListener('click', ()=> select(idx));
    cell.addEventListener('keydown', onKeyCell);
    return cell;
  }

  function render(){
    if(!gridEl.children.length){
      for(let i=0;i<size;i++) gridEl.appendChild(makeCell(i));
    }
    for(let i=0;i<size;i++){
      const cellEl = gridEl.children[i];
      const valueEl = cellEl.querySelector('.value');
      const pencilsEl = cellEl.querySelector('.pencils');
      const cell = board[i];
      // value layer
      valueEl.textContent = cell.value ? String(cell.value) : '';
      valueEl.className = 'value ' + (cell.value ? (cell.given?'given':'user') : '');
      // pencils layer
      [...pencilsEl.children].forEach(p=>{
        const d = Number(p.dataset.d);
        p.className = 'pencil' + (cell.pencil.has(d) && !cell.value ? ' on' : '');
      });
      // conflicts
      const conflict = isConflictAt(i);
      if(conflict && cell.value){ valueEl.classList.add('conflict'); }
      else valueEl.classList.remove('conflict');
    }
  }

  function select(i){
    selected = i;
    for(let j=0;j<size;j++){
      gridEl.children[j].setAttribute('aria-selected', j===i ? 'true':'false');
    }
    gridEl.children[i].focus({preventScroll:true});
  }

  /*** Rules & Conflicts ***/
  function peersOf(i){
    const [r,c]=rc(i); const peers=new Set();
    for(let k=0;k<9;k++){ peers.add(r*9+k); peers.add(k*9+c); }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let rr=0; rr<3; rr++) for(let cc=0; cc<3; cc++) peers.add((br+rr)*9+(bc+cc));
    peers.delete(i); return [...peers];
  }
  function isConflictAt(i){
    const v=board[i].value; if(!v) return false; const [r,c]=rc(i);
    for(let k=0;k<9;k++){
      const ri=r*9+k, ci=k*9+c; if(ri!==i && board[ri].value===v) return true; if(ci!==i && board[ci].value===v) return true;
    }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let rr=0; rr<3; rr++) for(let cc=0; cc<3; cc++){
      const idx=(br+rr)*9+(bc+cc); if(idx!==i && board[idx].value===v) return true;
    }
    return false;
  }
  /*** Candidates & Logic Rules ***/
  function candidatesFor(i){
    if(board[i].value) return new Set();
    const used = new Set();
    const [r,c]=rc(i);
    for(let k=0;k<9;k++){ const a=r*9+k, b=k*9+c; if(board[a].value) used.add(board[a].value); if(board[b].value) used.add(board[b].value); }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let rr=0; rr<3; rr++) for(let cc=0; cc<3; cc++){ const idx=(br+rr)*9+(bc+cc); if(board[idx].value) used.add(board[idx].value); }
    return new Set(DIGITS.filter(d=>!used.has(d)));
  }
  function computeCandidates(){
    for(let i=0;i<size;i++){
      if(board[i].value==null){ board[i].pencil = candidatesFor(i); } else { board[i].pencil.clear(); }
    }
  }
  function setValue(i,d){ board[i].value=d; board[i].pencil.clear(); }
  function applyNakedSingles(){ let placed=0; for(let i=0;i<size;i++){ if(board[i].value==null && board[i].pencil.size===1){ const d=[...board[i].pencil][0]; setValue(i,d); placed++; } } return placed; }
  function applyHiddenSingles(){
    let placed=0; const UNITS=[...ROWS,...COLS,...BOXES];
    for(const unit of UNITS){ for(const d of DIGITS){ const spots=unit.filter(i=> board[i].value==null && board[i].pencil.has(d)); if(spots.length===1){ setValue(spots[0],d); placed++; } } }
    return placed;
  }
  function applyPointing(){
    let removed=0; for(let b=0;b<9;b++){ const box=BOXES[b];
      for(const d of DIGITS){ const inBox=box.filter(i=> board[i].value==null && board[i].pencil.has(d)); if(inBox.length<=1) continue;
        const rows=new Set(inBox.map(i=> Math.floor(i/9))); const cols=new Set(inBox.map(i=> i%9));
        if(rows.size===1){ const r=[...rows][0]; for(const i of ROWS[r]){ if(!box.includes(i) && board[i].value==null && board[i].pencil.delete(d)) removed++; } }
        if(cols.size===1){ const c=[...cols][0]; for(const i of COLS[c]){ if(!box.includes(i) && board[i].value==null && board[i].pencil.delete(d)) removed++; } }
      }
    }
    return removed;
  }
  function logicStep(){ computeCandidates(); let progressed=false; while(true){ const n=applyNakedSingles(); if(n===0) break; progressed=true; computeCandidates(); }
    const h=applyHiddenSingles(); if(h>0){ progressed=true; computeCandidates(); }
    const p=applyPointing(); if(p>0){ progressed=true; }
    render(); return progressed; }
  function autoSolve(){ let any=false; do{ any=logicStep(); }while(any); }

  /*** Input Handling ***/
  function handleDigit(d, fromPencilClick=false){
    const cell = board[selected]; if(cell.given) return; // can't change given
    pushHistory();
    if(realPencilMode()){
      if(cell.value){ cell.value=null; }
      if(cell.pencil.has(d)) cell.pencil.delete(d); else cell.pencil.add(d);
    } else {
      cell.value = d;
      cell.pencil.clear();
    }
    render();
  }
  function clearCell(){ const cell=board[selected]; if(cell.given) return; pushHistory(); cell.value=null; cell.pencil.clear(); render(); }
  function onKeyCell(e){
    const k=e.key;
    if(k>='1'&&k<='9'){ handleDigit(Number(k)); return e.preventDefault(); }
    if(k==='0' || k==='Backspace' || k==='Delete'){ clearCell(); return e.preventDefault(); }
    if(k==='ArrowLeft') { select(Math.max(0, selected-1)); return e.preventDefault(); }
    if(k==='ArrowRight'){ select(Math.min(size-1, selected+1)); return e.preventDefault(); }
    if(k==='ArrowUp')   { select(Math.max(0, selected-9)); return e.preventDefault(); }
    if(k==='ArrowDown') { select(Math.min(size-1, selected+9)); return e.preventDefault(); }
    if(k==='z' && (e.ctrlKey||e.metaKey)) { undo(); return e.preventDefault(); }
    if(k==='y' && (e.ctrlKey||e.metaKey)) { redo(); return e.preventDefault(); }
    if(k===' ') { pencilMode = !pencilMode; updateModeUI(); return e.preventDefault(); }
    if(k==='Tab'){ e.preventDefault(); select((selected+1)%size); }
  }
  window.addEventListener('keydown', e=>{ if(e.key==='Shift') { shiftHeld = true; updatePencilVisibility(); }});
  window.addEventListener('keyup', e=>{ if(e.key==='Shift') { shiftHeld = false; updatePencilVisibility(); }});
  function realPencilMode(){ return pencilMode || shiftHeld; }
  function updateModeUI(){
    modeLabel.textContent = realPencilMode()? '铅笔' : '数字';
    modeSwitch.classList.toggle('on', pencilMode);
    modeSwitch.setAttribute('aria-checked', String(pencilMode));
    updatePencilVisibility();
  }

  /*** Buttons ***/
  document.getElementById('eraseBtn').onclick = clearCell;
  document.getElementById('undoBtn').onclick = undo;
  document.getElementById('redoBtn').onclick = redo;
  document.getElementById('clearBtn').onclick = ()=>{ pushHistory(); board.forEach(c=>{ if(!c.given){ c.value=null; c.pencil.clear(); } }); render(); };
  document.getElementById('lockBtn').onclick = ()=>{ pushHistory(); board.forEach(c=>{ if(c.value){ c.given=true; } }); render(); };
  document.getElementById('unlockBtn').onclick = ()=>{ pushHistory(); board.forEach(c=> c.given=false); render(); };
  modeSwitch.addEventListener('click', ()=>{ pencilMode = !pencilMode; updateModeUI(); });
  modeSwitch.addEventListener('keydown', e=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); pencilMode=!pencilMode; updateModeUI(); }});

  // Solver buttons
  document.getElementById('candsBtn').onclick = ()=>{ pushHistory(); computeCandidates(); render(); };
  document.getElementById('stepBtn').onclick = ()=>{ pushHistory(); logicStep(); };
  document.getElementById('autoBtn').onclick = ()=>{ pushHistory(); autoSolve(); };

  /*** Import/Export ***/
  function serialize(){
    return board.map(c=>({v:c.value, g:c.given, p:[...c.pencil]}));
  }
  function deserialize(data){
    board = data.map(x=>({value:x.v??null, given:!!x.g, pencil:new Set(x.p)}));
  }
  function exportJSON(){
    const data = JSON.stringify(serialize());
    ioArea.value = data;
    const blob = new Blob([data], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sudoku.json'; a.click(); URL.revokeObjectURL(a.href);
  }
  function importJSON(text){
    try{
      if(text.trim().length===81 && /^[-.0-9]+$/.test(text.trim())){
        // 81-char digits string
        pushHistory();
        board = Array.from({length:size}, (_,i)=>{
          const ch = text[i]; const n = (ch==='.'||ch==='0')? 0 : Number(ch);
          return { value: n? n: null, given: !!n, pencil: new Set() };
        });
        render(); select(0); return;
      }
      const parsed = JSON.parse(text);
      if(Array.isArray(parsed) && parsed.length===size){ pushHistory(); deserialize(parsed); render(); select(0); }
      else alert('格式不正确：需要 81 长度字符串或导出的 JSON');
    }catch(err){ alert('解析失败：'+err.message); }
  }
  document.getElementById('exportBtn').onclick = exportJSON;
  document.getElementById('importBtn').onclick = ()=> importJSON(ioArea.value);
  document.getElementById('saveBtn').onclick = ()=>{ localStorage.setItem('sudoku-mini-board', JSON.stringify(serialize())); alert('已保存到本地浏览器'); };

  /*** Minimal Self-Tests (console) ***/
  function selfTests(){
    const ok = [];
    ok.push(ROWS.length===9 && COLS.length===9 && BOXES.length===9);
    // Empty board: center cell has 9 candidates
    const snapshot = cloneBoard(board);
    board = Array.from({length:size},()=>({value:null,given:false,pencil:new Set()}));
    const cands = candidatesFor(40); // center
    ok.push(cands.size===9);
    // Simple row constraint: put 1..8 on row 4 except last cell, then last should have only candidate 9
    for(let c=0;c<8;c++) board[4*9+c].value=c+1;
    computeCandidates();
    ok.push(board[4*9+8].pencil.size===1 && [...board[4*9+8].pencil][0]===9);
    // restore
    board = snapshot;
    if(ok.every(Boolean)){
      console.log('[SelfTest] PASS');
    } else {
      console.warn('[SelfTest] FAIL', ok);
    }
  }
  // Run once on load (non-destructive)
  selfTests();

  // Load from localStorage if present
  (function init(){
    render(); select(0); updateModeUI(); updatePencilVisibility();
    const saved = localStorage.getItem('sudoku-mini-board');
    if(saved){ try{ deserialize(JSON.parse(saved)); render(); } catch(e){ console.warn('Restore failed:', e); } }
  })();
})();
</script>
</body>
</html>
